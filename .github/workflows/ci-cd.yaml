name: CI/CD for Fr. Youhanna Makin

on:
  push:
    branches:
      - main
    tags:
      - "v*"
  pull_request:
    branches:
      - main

env:
  DOCKER_REGISTRY: docker.io
  DOCKER_IMAGE: ${{ secrets.DOCKER_USERNAME }}/fr-youhanna-makin
  K8S_NAMESPACE: fr-youhanna-makin

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'push'

    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: fr_youhanna_makin_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2.2"
          bundler-cache: true

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "16"
          cache: "yarn"

      - name: Install dependencies
        run: |
          bundle install
          yarn install

      - name: Set up database
        env:
          RAILS_ENV: test
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/fr_youhanna_makin_test
        run: |
          bundle exec rails db:create
          bundle exec rails db:schema:load

      - name: Run Rails tests
        env:
          RAILS_ENV: test
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/fr_youhanna_makin_test
        run: bundle exec rspec

      - name: Run JavaScript tests
        run: yarn test

      - name: Run linting
        run: |
          bundle exec rubocop
          yarn lint

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v'))

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Set image tag
        id: set-tag
        run: |
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            TAG=${GITHUB_REF#refs/tags/}
            echo "IMAGE_TAG=${TAG}" >> $GITHUB_ENV
          else
            SHA=$(git rev-parse --short $GITHUB_SHA)
            echo "IMAGE_TAG=sha-${SHA}" >> $GITHUB_ENV
          fi

      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE }}:${{ env.IMAGE_TAG }}
            ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE }}:latest
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE }}:buildcache,mode=max

  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v'))

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set image tag
        id: set-tag
        run: |
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            TAG=${GITHUB_REF#refs/tags/}
            echo "IMAGE_TAG=${TAG}" >> $GITHUB_ENV
          else
            SHA=$(git rev-parse --short $GITHUB_SHA)
            echo "IMAGE_TAG=sha-${SHA}" >> $GITHUB_ENV
          fi

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "v1.24.0"

      - name: Save DigitalOcean kubeconfig
        run: doctl kubernetes cluster kubeconfig save ${{ secrets.DIGITALOCEAN_CLUSTER_NAME }}

      - name: Create namespace if not exists
        run: kubectl create namespace ${{ env.K8S_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Create Docker Hub secret
        run: |
          kubectl create secret docker-registry dockerhub-secret \
            --namespace=${{ env.K8S_NAMESPACE }} \
            --docker-server=${{ env.DOCKER_REGISTRY }} \
            --docker-username=${{ secrets.DOCKER_USERNAME }} \
            --docker-password=${{ secrets.DOCKER_PASSWORD }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create application secrets
        run: |
          DOCKER_CONFIG_JSON=$(echo -n '{"auths":{"'${{ env.DOCKER_REGISTRY }}'":{"username":"'${{ secrets.DOCKER_USERNAME }}'","password":"'${{ secrets.DOCKER_PASSWORD }}'"}}}' | base64 -w 0)

          # Replace placeholders in the secret template
          sed -e "s|\${DATABASE_URL}|${{ secrets.DATABASE_URL }}|g" \
              -e "s|\${RAILS_MASTER_KEY}|${{ secrets.RAILS_MASTER_KEY }}|g" \
              -e "s|\${ADMIN_PASSWORD}|${{ secrets.ADMIN_PASSWORD }}|g" \
              -e "s|\${DOCKER_CONFIG_JSON}|${DOCKER_CONFIG_JSON}|g" \
              k8s/secret.yaml.template > k8s/secret.yaml

          # Apply the secret
          kubectl apply -f k8s/secret.yaml -n ${{ env.K8S_NAMESPACE }}

          # Remove the file with secrets
          rm k8s/secret.yaml

      - name: Deploy application
        run: |
          # Replace placeholders in the deployment files
          sed -e "s|\${DOCKER_USERNAME}|${{ secrets.DOCKER_USERNAME }}|g" \
              -e "s|\${IMAGE_TAG}|${{ env.IMAGE_TAG }}|g" \
              k8s/deployment.yaml > k8s/deployment-with-image.yaml

          sed -e "s|\${DOCKER_USERNAME}|${{ secrets.DOCKER_USERNAME }}|g" \
              -e "s|\${IMAGE_TAG}|${{ env.IMAGE_TAG }}|g" \
              k8s/database-init.yaml > k8s/database-init-with-image.yaml

          # Apply Kubernetes manifests
          kubectl apply -f k8s/configmap.yaml -n ${{ env.K8S_NAMESPACE }}
          kubectl apply -f k8s/pvc.yaml -n ${{ env.K8S_NAMESPACE }}

          # Run database migration job first - only on initial deployment or when specifically needed
          if [[ "${{ github.ref }}" == "refs/heads/main" && "${{ github.event.repository.created_at }}" == "${{ github.event.repository.updated_at }}" ]] || [[ "${{ contains(github.event.head_commit.message, '[db-migrate]') }}" == "true" ]]; then
            echo "Running database migration job..."
            kubectl apply -f k8s/database-init-with-image.yaml -n ${{ env.K8S_NAMESPACE }}
            kubectl wait --for=condition=complete --timeout=180s job/fr-youhanna-makin-db-init -n ${{ env.K8S_NAMESPACE }}
          fi

          # Apply remaining resources
          kubectl apply -f k8s/deployment-with-image.yaml -n ${{ env.K8S_NAMESPACE }}
          kubectl apply -f k8s/service.yaml -n ${{ env.K8S_NAMESPACE }}
          kubectl apply -f k8s/ingress.yaml -n ${{ env.K8S_NAMESPACE }}

          # Remove the file with image details
          rm k8s/deployment-with-image.yaml
          rm k8s/database-init-with-image.yaml

      - name: Wait for deployment to complete
        run: |
          kubectl rollout status deployment/fr-youhanna-makin -n ${{ env.K8S_NAMESPACE }} --timeout=300s

  generate-docs:
    name: Generate Documentation
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2.2"
          bundler-cache: true

      - name: Install yard
        run: gem install yard

      - name: Generate Rails documentation
        run: |
          yard doc app lib --output-dir docs/api

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "16"

      - name: Install TypeDoc
        run: npm install -g typedoc

      - name: Generate TypeScript documentation
        run: |
          typedoc --out docs/frontend app/frontend

      - name: Generate deployment documentation
        run: |
          mkdir -p docs/deployment
          cp docs/deployment.md docs/deployment/index.md

          # Generate Kubernetes manifest documentation
          echo "# Kubernetes Configuration" > docs/deployment/kubernetes.md
          echo "\nThis document describes the Kubernetes manifests used for deployment.\n" >> docs/deployment/kubernetes.md

          for file in k8s/*.yaml k8s/*.yaml.template; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "\n## $filename\n" >> docs/deployment/kubernetes.md
              echo '```yaml' >> docs/deployment/kubernetes.md
              cat "$file" >> docs/deployment/kubernetes.md
              echo '```' >> docs/deployment/kubernetes.md
            fi
          done

      - name: Upload documentation as artifact
        uses: actions/upload-artifact@v3
        with:
          name: documentation
          path: docs/
          retention-days: 7

      - name: Deploy documentation to GitHub Pages (if configured)
        uses: peaceiris/actions-gh-pages@v3
        if: github.repository_owner == github.actor
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs
